! optimal knowledge class for solving and simulating model
! version with MPI capabilities
! Lusardi, Michaud and Mitchell
! mpif90 knowX.f95 dcdflib.a -o know (with mpi support)
! with differential mortality and share invested in stocks

module know
!use mpi
implicit none
include 'mpif.h'

!* general parameters
integer T									! number of years in model
integer ny, ne, nd, nf, na, no, nr, nq, ns	! grid size
integer nsim								! number of simulated agents
character (len=80) :: path					! path to data
character(len=100) filename					! file name when saving value function
character(len=4) fileid						! file id when saving value function


!* parameters for calibration
double precision beta, gamma, umin					! preferences
double precision delta0,delta1 						! depreciation of knowledge
double precision rmin, rmax, rbar, sigr, rhor,alpha0,alpha1		! interest rate parameters
double precision k0, k1, phi, pi0,pi1					! cost of technology
double precision inflation							! rate of inflation
   
!* auxiliary process parameters and arrays
double precision bw(6,3), bo(6,3),br(36,3),incsig(3)			! income and oop parameters
double precision, allocatable :: ptey(:,:), proby(:,:,:), cumproby(:,:,:)
double precision, allocatable :: pteo(:,:), probo(:,:,:), cumprobo(:,:,:)
double precision, allocatable :: pter(:), probr(:), cumprobr(:), vprobr(:)

!: mortality rates and equivalence scales
double precision, allocatable :: mort(:,:), eq(:,:)

!* other global variables
double precision cmin, eps_c, eps_i
integer retage(3)

!* grid of continuous state variables
double precision, allocatable :: gridf(:)			! grid for knowledge
double precision fmin, fmax, gapf
double precision, allocatable :: grida(:)			! grid for assets
double precision amin, amax, gapa
double precision, allocatable :: gridd(:)			! grid for risky asset share
double precision dmin, dmax, gapd
integer, allocatable :: lookup(:,:)					! look up array for grid point
!* array for results (all allocated later)
double precision, allocatable :: vopt(:,:,:,:,:)	! value function
double precision, allocatable :: dopt(:,:,:,:,:)	! share invested in technology
double precision, allocatable :: fopt(:,:,:,:,:)	! financial knowledge stock
double precision, allocatable :: aopt(:,:,:,:,:)	! assets
double precision, allocatable :: copt(:,:,:,:,:)	! consumption
double precision, allocatable :: iopt(:,:,:,:,:)	! investment

! arrays for simulation
integer, allocatable :: esim(:,:)
double precision, allocatable :: csim(:,:), isim(:,:), fsim(:,:), asim(:,:), vsim(:,:), dsim(:,:)
integer, allocatable :: ysim(:,:), osim(:,:), rsim(:,:), dead(:,:)
double precision, allocatable :: incsim(:,:), oopsim(:,:)

! MPI globals
integer ier, rank, numprocs, numworkers, status(MPI_STATUS_SIZE),maxsize
logical ismaster
real*8 starttime, endtime, totaltime

contains

	subroutine initmpi
		integer ier
		call mpi_init(ier)
		call mpi_comm_size(MPI_COMM_WORLD,numprocs,ier)
		call mpi_comm_rank(MPI_COMM_WORLD,rank,ier)
		numworkers = numprocs - 1
		
		if (rank.eq.0) then
			ismaster = .true.
		else
			ismaster = .false.
		end if	
		if (ismaster) then
			write(*,*) 'mpi initialized ...'
			write(*,*) ' # of procs 	  :', numprocs
			write(*,*) ' # of workers 	  :', numworkers
			call flush()
		end if	
		starttime = MPI_WTIME()
	end subroutine initmpi
	
	subroutine stopmpi
		! CODE TO BE TIMED
		endtime = MPI_WTIME()
		totaltime = endtime - starttime	
		if (ismaster) then
			write(*,*) 'total time taken for code =',totaltime
			call flush()
		end if
		
		call flush()
		!write(*,*) 'finalized process', rank
		call flush()
		call mpi_finalize(ier)
	end subroutine stopmpi
	
	subroutine initpar
		! assignment of structural parameters from file generated by Stata		
		open(unit=1, file='/brinker-5/a/michaud/fin/data/structural-parameters.asc')
		read(1,*) ! reading header
		read(1,*) beta
		read(1,*) gamma
		read(1,*) pi0
		read(1,*) pi1
		read(1,*) cmin
		read(1,*) k0
		read(1,*) k1
		read(1,*) phi
		read(1,*) delta0
		read(1,*) delta1
		read(1,*) alpha0
		read(1,*) alpha1		
		close(unit=1)
		! assignment of other parameters from file generated by Stata
		open(unit=1, file='/brinker-5/a/michaud/fin/data/other-parameters.asc')
		read(1,*) ! reading header
		read(1,*) amin
		read(1,*) amax
		read(1,*) fmin
		read(1,*) fmax
		read(1,*) inflation
		read(1,*) rmax
		read(1,*) rbar
		read(1,*) sigr
		read(1,*) retage(1)
		close(unit=1)
		! assignment of dimensions (grid, nsim) from file generated by Stata
		open(unit=1, file='/brinker-5/a/michaud/fin/data/dimensions-parameters.asc')
		read(1,*) ! reading header
		read(1,*) T
		read(1,*) ny
		read(1,*) no
		read(1,*) nr
		read(1,*) ne
		read(1,*) nd
		read(1,*) nf		
		read(1,*) na
		read(1,*) nsim
		close(unit=1)	
		
		! retirement periods (25 + x)
		retage(2) = retage(1) 
		retage(3) = retage(1)
		! set path 
		path = '/brinker-5/a/michaud/fin/data/'
		! minimum utility
		umin = -10.0d6
		
		if (ismaster) then
			write(*,*) '! parameter values initialized ...'
			call flush()
		end if
	end subroutine initpar
	
	subroutine statespace
		integer i, state, y, o, e, f, a
		! number of income/oop shocks
		nq = no*ny
		! bounds for share invested in stocks
		dmax = 1.0d0
		dmin = 0.0d0
		! allocate space for grid of assets and fin knowledge
		allocate(grida(na))
		allocate(gridf(nf))
		allocate(gridd(nd))
		!define and initialize asset and knowledge grid: 
		gapa = (dsqrt(amax) - dsqrt(amin))/dble(na-1)
		gapf = (fmax - fmin)/dble(nf-1)
		!write(*,*) gapa, gapf
		do i=1, na, 1
			grida(i) = dsqrt(amin) + dble(i-1)*gapa
			!write(*,*) i,grida(i),grida(i)**2
		end do
		do i=1, nf, 1
			gridf(i) = fmin + dble(i-1)*gapf
		end do
		gapd = (dmax - dmin)/dble(nd-1)
		if (nd.ge.2) then
		do i = 1, nd, 1
			gridd(i) = dmin + dble(i-1)*gapd
		end do
		else
			gridd(1) = 0.0d0
		end if
		
		! allocate space for solution
		allocate(vopt(T,nq,ne,nf,na))			! value function
		allocate(dopt(T,nq,ne,nf,na))			! utility diff technology
		allocate(fopt(T,nq,ne,nf,na))			! financial knowledge stock
		allocate(aopt(T,nq,ne,nf,na))			! assets
		allocate(copt(T,nq,ne,nf,na))			! consumption
		allocate(iopt(T,nq,ne,nf,na))			! investment
		
		! grid of income shocks
		if (ismaster) then
			write(*,*) '- will now initialize income shocks ...'
		end if
			call income_shocks

		! grid of oop shocks
		if (ismaster) then
			write(*,*) '- will now initialize oop shocks ...'
		end if	
			call oop_shocks

		! rate of return on sophisticated technology		
		if (ismaster) then
			write(*,*) '- will now initialize return risks ...'
		end if	
			call rate_shocks
			
		! mortality rates
		if (ismaster) then
			write(*,*) '- will now initialize mortality rates ...'
		end if
		! loading coefficients
		allocate(mort(T,ne))
		open(unit=2,file='/brinker-5/a/michaud/fin/data/mortality1940-hrs.csv') 
		! reading header
		read(2,*)
		do i =  1 ,T, 1 
			mort(i,:) = 0.0d0
			read(2,*) mort(i,:)	
			do e= 1, ne, 1
				!mort(i,e) = mort(i,2)
			end do
			!write(*,*) i,mort(i,:)
		end do 
		close(unit=2) 
			
		! equivalence scales
		if (ismaster) then
			write(*,*) '- will now initialize equivalence scales ...'
		end if
		allocate(eq(T,ne))
		! loading coefficients
		open(unit=3,file='/brinker-5/a/michaud/fin/data/equivalence.csv') 
		read(3,*) 
		do i =  1 ,T 
			read(3,*) eq(i,:)	
			do e = 1, ne, 1
				!eq(i,e) = eq(i,2)
			end do
			!write(*,*) i,eq(i,:)
		end do 
		close(unit=3) 
		
		ns = nq*ne*nf*na
		maxsize = floor(3.0*dble(ns)/dble(numworkers))
		! allocate space for lookup array
		allocate(lookup(ns,5))
		! fill in look up array
		state = 0
		do y = 1, ny, 1
			do o = 1, no, 1
				do e = 1, ne, 1
						do f = 1, nf, 1
							do a = 1, na, 1
								state = state + 1			
								lookup(state,1) = y
								lookup(state,2) = o
								lookup(state,3) = e
								lookup(state,4) = f
								lookup(state,5) = a
							end do
						end do
				end do
			end do
		end do
		
		! set tolerance for consumption and investment choice
		eps_c = 10.0d0
		eps_i = 0.1d0
		
		if (ismaster) then
			write(*,*) '! state space initialized ...'
			write(*,*) '   - state space has total of ',T*ns, ' points'
			write(*,*) '                              ',ns, ' per year'
		end if
		call flush()
	end subroutine statespace

	subroutine income_shocks
		integer e, i, j
		double precision ny1, prob, sig, rho, sump, mu, m, gap, sige
		
		! allocate space for probabilities
		allocate(ptey(ne,ny))
		allocate(proby(ne,ny,ny))
		allocate(cumproby(ne,ny,ny))
		
		! run income.(do,ox) to get par estimates, need modify csv file
		!				lhs           hs          col
		!age        0.047557     0.083155     0.098741
		!age2      -0.044539    -0.083713    -0.098778
		!const        9.2826       8.7459       8.6354
		!rho         0.93856      0.94849      0.92575
		!sige       0.047679     0.025018     0.032197
		!sigv        0.11854      0.20310     0.082914

		! read parameters		
		open(unit=1, file='/brinker-5/a/michaud/fin/data/incomeworkpar.csv')
		do i = 1, 6, 1
			read(1,*) bw(i,:)
			!bw(i,:) = bw(i,2)
			!write(*,*) i,bw(i,:)
		end do
		close(unit=1)
		! Increased uncertainty
		do i = 1, 3, 1
			!bw(5,i) = bw(5,i)*1.25d0
		! allow for half transitory variance
			bw(6,i) = bw(6,i)*0.0d0		
		end do
		! lowering variance policy
		!bw(5,1) = 0.5d0*bw(5,1); bw(5,2) = 0.5d0*bw(5,2);; bw(5,3) = 0.5d0*bw(5,3);
		!bw(6,1) = 0.5d0*bw(6,1); bw(6,2) = 0.5d0*bw(6,2);; bw(6,3) = 0.5d0*bw(6,3);
		
		
		! use method of Tauchen (1986)
		m = 2.5d0
		if (ny.eq.1) then
			do e = 1, 3, 1
				ptey(e,1) = 0.0d0
				proby(e,1,1) = 1.0d0
				cumproby(e,1,1) = 1.0d0
			end do
		else	
		ny1 = dble(ny)-1.0d0 
		do e = 1, 3, 1
			! compute unconditional standard deviation
			rho = bw(4,e)
			sige = dsqrt(bw(5,e) + bw(6,e))
			sig = dsqrt((sige**2)/(1.0d0-rho**2) + bw(6,e)) 
			incsig(e) = sig**2
			! grid  points
			ptey(e,1) = -m*sig
			ptey(e,ny) = m*sig
			gap = (2.0d0*m*sig)/ny1
			! Fill in between
			do i=2, ny-1, 1
				ptey(e,i) = ptey(e,1) + dble(i-1)*gap
			end do
			
			! compute probabilities
			do i = 1, ny, 1
				do j = 1, ny, 1
					if (j.eq.1) then
						proby(e,i,1) = probn((ptey(e,j)+gap/2.0d0 - rho*ptey(e,i))/sige)
						cumproby(e,i,1) = proby(e,i,1)
					
					else if (j.gt.1 .and. j.lt.ny) then
						proby(e,i,j) = probn((ptey(e,j)+gap/2.0d0 - rho*ptey(e,i))/sige) - probn((ptey(e,j)-gap/2.0d0 - rho*ptey(e,i))/sige)
						cumproby(e,i,j) = proby(e,i,j) + cumproby(e,i,j-1) 
					
					else
						proby(e,i,ny) = 1.0d0 - probn((ptey(e,j)-gap/2.0d0 - rho*ptey(e,i))/sige)
						cumproby(e,i,ny) = 1.0d0	
					end if
					!write(*,*) e,i,j,ptey(e,i),ptey(e,j),proby(e,i,j),cumproby(e,i,j)
				end do
			end do
		end do
		end if

		! input retirement income
		! read parameters		
		open(unit=1, file='/brinker-5/a/michaud/fin/data/ret-income.csv')
		read(1,*) ; ! reading header
		do i = 1, 36, 1
			read(1,*) br(i,:)
			!write(*,*) br(i,:)
			! retirement policy
			do j = 1, 3, 1
				!br(i,j) = br(i,j)*0.73d0
				
			end do	
			!write(*,*) i,br(i,:)
			br(i,1) = 0.86d0*br(i,1)
			br(i,2) = 0.73d0*br(i,2)
			br(i,3) = 0.70d0*br(i,3)
			!br(i,:) = 0.72d0
		end do
		close(unit=1)		


		! Policy change for retirement 
		!br(3,1) = br(3,1) + 0.25d0; br(3,2) = br(3,2) + 0.25d0; br(3,3) = br(3,3) + 0.25d0		

	end subroutine income_shocks

	subroutine oop_shocks
		integer i,j,e
		double precision sig,sump,rho,prob, no1 , mu , m, gap, sige
		! allocate space for probabilities
		allocate(pteo(ne,no))
		allocate(probo(ne,no,no))
		allocate(cumprobo(ne,no,no))

		! run oop.(do,ox) to get par estimates, need modify csv file
		!				lhs           hs          col
		!age        -0.13145     -0.13145     -0.13145
		!agesq      0.097660     0.097660     0.097660
		!const        11.982       12.182       12.349
		!rho         0.80256      0.76211      0.79478
		!sige        0.24608      0.30336      0.25765
		!sigv        0.75855      0.58052      0.60452

		
		! read parameters		
		open(unit=2, file='/brinker-5/a/michaud/fin/data/ooppar.csv')
		do i = 1, 6, 1
			read(2,*) bo(i,:)
			!bo(i,:) = bo(i,2)
			!write(*,*) i,bo(i,:)
		end do
		bo(6,:) = 0.0d0
		close(unit=2)
		
		! use method of Tauchen (1986)
		m = 2.5d0
		if (no.eq.1) then
			do e = 1, ne, 1
				pteo(e,1) = 0.0d0
				probo(e,1,1) = 1.0d0
				cumprobo(e,1,1) = 1.0d0
			end do
		else	
		no1 = dble(no)-1.0d0 
		do e = 1, ne, 1
			! compute unconditional standard deviation
			rho = bo(4,e)
			sige = dsqrt(bo(5,e) + bo(6,e))
			sig = dsqrt((sige**2)/(1.0d0-rho**2) + bo(6,e)) 
			! grid  points
			pteo(e,1) = -m*sig
			pteo(e,no) = m*sig
			gap = (2.0d0*m*sig)/no1
			! Fill in between
			do i=2, no-1, 1
				pteo(e,i) = pteo(e,1) + dble(i-1)*gap
			end do
			
			! compute probabilities
			do i = 1, no, 1
				do j = 1, no, 1
					if (j.eq.1) then
						probo(e,i,1) = probn((pteo(e,j)+gap/2.0d0 - rho*pteo(e,i))/sige)
						cumprobo(e,i,1) = probo(e,i,1)
					
					else if (j.gt.1 .and. j.lt.no) then
						probo(e,i,j) = probn((pteo(e,j)+gap/2.0d0 - rho*pteo(e,i))/sige) - probn((pteo(e,j)-gap/2.0d0 - rho*pteo(e,i))/sige)
						cumprobo(e,i,j) = probo(e,i,j) + cumprobo(e,i,j-1) 
					
					else
						probo(e,i,no) = 1.0d0 - probn((pteo(e,j)-gap/2.0d0 - rho*pteo(e,i))/sige)
						cumprobo(e,i,no) = 1.0d0	
					end if
					!write(*,*) e,i,j,pteo(e,i),pteo(e,j),probo(e,i,j),cumprobo(e,i,j)
					
				end do
			end do
		end do
		end if
		!write(*,*) bo 
	end subroutine oop_shocks

	subroutine rate_shocks
		integer i
		double precision nr1, gap, m
		
		! allocate space for probabilities
		allocate(cumprobr(nr))
		allocate(pter(nr))
		allocate(probr(nr))
		
		! compute probabilities and quantiles
		
		if (nr.eq.1) then
			pter(1) = 0.0d0
			probr(1) = 1.0d0
			cumprobr(1) = 1.0d0
		else	
			m = 3.0d0
			! grid  points
			nr1 = dble(nr)- 1.0d0
			gap = (2.0d0*m*sigr)/nr1
			pter(1) = -m*sigr
			probr(1) = probn((pter(1)+gap/2.0d0)/sigr)
			cumprobr(1) = probr(1)
			! Fill in between
			do i=2, nr-1, 1
				pter(i) = pter(1) + dble(i-1)*gap
				probr(i) = probn((pter(i)+gap/2.0d0)/sigr) - probn((pter(i)-gap/2.0d0)/sigr)
				cumprobr(i) = cumprobr(i-1) + probr(i)
			end do
			pter(nr) = m*sigr
			probr(nr) = 1.0d0-probn((pter(nr)-gap/2.0d0)/sigr)
			cumprobr(nr) = 1.0d0
		end if
		!write(*,*) probr
		!write(*,*) 'check on production function '
		!write(*,*) 'nf = ', factor(gridf(10), gridd(nd), 0.0d0)
			do i = 1, nd, 1
				!write(*,*) gridd(i),factor(gridf(nf), gridd(i), 0.0d0)
				call flush()
			end do
	end subroutine rate_shocks

	subroutine solve
		! compute problem last period
		call termination
		! compute recursion
		call recursion				
	end subroutine solve

	subroutine termination
		integer y, o, e, f, a, q
		double precision inc, med, eqcmin, x
		
		if (ismaster) then
			write(*,*) '- computing termination value ...' 
			20      format (3f8.1) 
		
			do y = 1, ny, 1
				do o = 1, no, 1
					do e = 1, ne, 1
						if (T.ge.retage(e)) then
							inc = retinc(T, e, ptey(e,y))
						else
							inc = earn(T, e, ptey(e,y))
						end if	
						med = oop(T,e, pteo(e,o))
						eqcmin = cmin*eq(T,e)/((2.7d0)**0.7)
						!write(*,*) T, e, y, o,  ptey(e,y)
							do f = 1, nf, 1
								!write(*,*) d,gridf(f),R
								do a = 1, na, 1
									x = grida(a)**2 + inc - med 
									if (x.lt.eqcmin) then
										x = eqcmin
									end if	
									call grid(y,o,q)
									vopt(T,q,e,f,a) = eq(T,e)*utility(x/eq(T,e))
									copt(T,q,e,f,a) = x
									dopt(T,q,e,f,a) = umin
									iopt(T,q,e,f,a) = 0.0d0
	!								write(*,20) inc,med,eqcmin
								end do
							end do
					end do
				end do
			end do

		end if	
		call flush()
	end subroutine termination

	subroutine recursion
		integer s, y, o, e, f, a, j, k, q, z, p
		integer nstate, state, sent, received, jobsize, nstates, index(4)
		integer sender, tag, i
		double precision result(maxsize,4), value(maxsize),nextvalue(ns)
		double precision cvalue(maxsize),ivalue(maxsize),dvalue(maxsize)
		logical finished
		if (ismaster) then
			write(*,*) '- starting recursion ...'
			end if
		do s=T-1, 1, -1	
			! start year
			if (ismaster) then						! Master's code
				jobsize = floor(dble(ns)/dble(numworkers))	
				!write(*,*) jobsize, numworkers*jobsize
				call flush()
				if (ismaster .and. (s.eq.70 .or. s.eq.50 .or. s.eq.25 .or. s.eq.1)) then
					write(*,*) 'at age', 25+s
					call flush()
				end if
				
				sent = 0
				
				
				
				! broadcast value function
				! save v(s) to file
				z = 1
				do y = 1, ny, 1
					do o = 1, no, 1
						call grid(y,o,q)
						do e = 1, ne, 1
								do f = 1, nf, 1
									do a = 1, na, 1				
										nextvalue(z) =  vopt(s+1,q,e,f,a)
										!write(*,*) q,e,f,a,nextvalue(z),vopt(s+1,q,e,f,a)
										z = z+1
									end do
								end do
						end do
					end do
				end do 
				
				call mpi_bcast(nextvalue,ns,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ier)	
				
				!write(*,*) 'master has broadcasted'
					call flush()
				! send jobs
				index(1) = 1
				do j = 1, numworkers, 1					
					! check that last index not ns
					if (j.eq.numworkers) then
						index(2) = ns
						index(3) = ns - index(1) + 1
					else
						index(2) = index(1) + jobsize - 1
						index(3) = jobsize
					end if
					index(4) = s
					!write(*,*) 'master sent ', index(3), 'to ', j
					call flush()
					call mpi_send(index, 4, MPI_INTEGER, j, 1, MPI_COMM_WORLD,ier)
					sent = sent + index(3)
					index(1) = index(2)+1
					if (sent.ge.ns) then
						exit
					end if	
				end do
				if (sent.lt.ns) then
					write(*,*) 'WARNING: Did not send all points'
				end if	
				!write(*,*) 'master sent messages'	
					call flush()
				! receive jobs and assign to arrays
				received = 0
				do while (received .lt. sent)
					! get first the indices from worker
					call mpi_recv(index, 4, MPI_INTEGER, MPI_ANY_SOURCE, MPI_ANY_TAG,MPI_COMM_WORLD,status,ier)
					! get who sent it
					sender = status(MPI_SOURCE)
					! then get data from that worker
					call mpi_recv(result,4*maxsize,MPI_DOUBLE_PRECISION,sender, MPI_ANY_TAG, MPI_COMM_WORLD, status, ier)
					received = received + index(3)
					! Assign his data to array of results
					i = 1
					do k = index(1), index(2), 1
						y = lookup(k,1)
						o = lookup(k,2)
						e = lookup(k,3)
						f = lookup(k,4)
						a = lookup(k,5)
						call grid(y,o,q)
						vopt(s,q,e,f,a) = result(i,1)
						dopt(s,q,e,f,a) = result(i,2) 
						copt(s,q,e,f,a) = result(i,3)
						iopt(s,q,e,f,a) = result(i,4)
						i = i + 1						
					end do
					if ((i-1).ne.index(3)) then
						write(*,*) 'received do not match by ', sender, i,index(1), index(2), index(3)
						call flush()
					end if	
				end do
					!write(*,*) 'master received messages'
						call flush()
													
			else									! Worker's code
		
			
				! retrieve information on job
				call mpi_bcast(nextvalue,ns,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ier)
				!write(*,*) 'worker ',rank,' got broadcast...'
					call flush()
				! now receive job to do
				call mpi_recv(index,4,MPI_INTEGER,0,MPI_ANY_TAG,MPI_COMM_WORLD,status,ier)
	
				!write(*,*) 'worker ',rank,' received task...'
						call flush()
						
					!write(*,*) 'worker ', rank, ' received job ', index
				!perform job
				call get_opt(index(4) ,index(1), index(2), index(3), value, dvalue, cvalue, ivalue, nextvalue)
					!write(*,*) 'worker ', rank, ' finished job ', index
				!write(*,*) index(3)
				!write(*,*) cvalue
					! return info
				result(1:index(3),1) = value
				result(1:index(3),2) = dvalue
				result(1:index(3),3) = cvalue
				result(1:index(3),4) = ivalue
				call mpi_send(index,4, MPI_INTEGER,0,rank,MPI_COMM_WORLD,ier)
				call mpi_send(result,4*maxsize,MPI_DOUBLE_PRECISION,0,rank,MPI_COMM_WORLD,ier)
				!write(*,*) 'worker ',rank,' sending back response...'			
						call flush()
			end if
			!write(*,*) 'process  ',rank,' got to barrier at ',s
				call flush()
			call mpi_barrier(MPI_COMM_WORLD, ier)
		
		end do
		
		call mpi_barrier(MPI_COMM_WORLD, ier)
		call flush()
	end subroutine recursion

											
	subroutine get_opt(s, sbegin, send, nstate, value, dvalue, cvalue, ivalue, nextvalue)
		! argument list
		integer s, nstate, sbegin, send, state, k 
		double precision value(nstate), dvalue(nstate), cvalue(nstate), ivalue(nstate)
		
		! variables to solve problem
		integer y, o, e, f, a, i, c, q, n, oi, p
		integer solution, nc, ni, maxd
		double precision inc, med,  eqcmin, z, bound_c(2), bound_i(2)
		double precision x, cost, guess, xn, oldc, oldi,nextvalue(ns)
		double precision cn, an, fn, in, u, ev, gapi, gapc,dif_c,dif_i,gapi_max
		double precision maxv, maxvd(nd), enough, maxc(nd), maxi(nd), maxvf
		double precision vnext(nq,ne,nf,na),cnext(nq,ne,nf,na),inext(nq,ne,nf,na)
		logical tech, tr
		nc = na
		
		! medical expenditure point when not yet retired
		if (no.gt.1) then
			oi = int(dble(no)/2.0d0)+1
		else
			oi = 1
		end if	
		
		! load next period's value function 
		p = 1
		do y = 1, ny, 1
			do o = 1, no, 1
				call grid(y,o,q)
				do e = 1, ne, 1
						do f = 1, nf, 1
							do a = 1, na, 1				
								vnext(q,e,f,a) = nextvalue(p)
								!write(*,*) p,vnext(q,e,f,a)
								p = p + 1
							end do
						end do
				end do
			end do
		end do 
		!write(*,*) 'nstate = ',nstate
		!write(*,*) 'worker ', rank, 'loaded value function ', vnext(1,1,1,1,1)
		do state = 1, nstate, 1
			! find out what is the state
			k = sbegin + state-1
			y =lookup(k,1)
			o =lookup(k,2)
			e =lookup(k,3)
			f =lookup(k,4)
			a =lookup(k,5)
			!write(*,*) 'worker ', rank, 'doing state ', k
			if (s.lt.retage(e) .and. o.ne.oi) then
				cycle
			end if
			! income shock
			if (s.ge.retage(e)) then
				inc = retinc(s, e, ptey(e,y))

			else
				inc = earn(s, e, ptey(e,y))
			end if
			! medical exp shock
			med = oop(s,e, pteo(e,o))
			!write(*,*) y,o,med
			! eqcmin
				eqcmin = cmin*eq(s,e)/((2.7d0)**0.7d0)

			!write(*,*) R
			! net financial knowledge
			z = fdepreciate(s)*gridf(f)
			! next year's solution for defining grid
			call grid(y,o,q)
			!write(*,*) 'state is ', s,y,o,q,e,d,f,a

			! cash-on-hand before contemplating decisions
			x = inc + grida(a)**2 - med
			
			! provide consumption floor if necessary (pay for meds)
			if (x.lt.eqcmin) then
				x = eqcmin
				tr = .true.
			else
				tr = .false.
			end if		
												
			! check whether technology can be bought
			cost = k0*dexp(-k1*z)
			if ((x-cost) .lt. eqcmin) then
				tech = .false.
			else
				tech = .true.
			end if	
			
			! define solution type
			if (tr) then
				solution = 1			! minimum consumption, no choice
			else
				if (.not. tech) then
					solution = 2	! technology is not affordable

				else 
					solution = 3		! technology is affordable and can be bought
				end if	
			end if
			!write(*,*) solution

			select case (solution)
				! 1st case: minimum consumption
				case (1)
					! compute consumption
					cn = x
					! asset next period
					an = amin
					! financial lit next period
					fn = z
					! compute utility
					u = eq(s,e)*utility(cn/eq(s,e))
					! get next period's value function (current fin lit, no assets)
					call get_ev(s , e, y, o, fn, an, 1, vnext, ev)	
					value(state) = u + (1.0d0-mort(s,e))*beta*ev 
					dvalue(state) = gridd(1)
					cvalue(state) = cn
					ivalue(state) = 0.0d0								
				! 2nd case: technology is not affordable									
				case (2)
					maxvd(1) = umin
					
					nc = int(dble(na))
					ni = int(dble(nf))
					xn = x
					bound_c(1) = eqcmin
					bound_c(2) = xn
					! start with coarse grid
					bound_i(1) = 0.0d0
					bound_i(2) = fmax - z
					dif_c = -umin
					dif_i = -umin
					oldc = 0.0d0
					oldi = 0.0d0

						gapc = (bound_c(2) - bound_c(1))/dble(nc-1)
						
						do c = 1, nc, 1
							cn = bound_c(1) + dble(c-1)*gapc
							if (bound_i(2).gt.finvcost(xn-cn)) then
								if (bound_i(2).gt.(fmax-z)) then
								bound_i(2) = fmax - z
								else 
									bound_i(2) = finvcost(xn-cn)
								end if
							end if	
							gapi = (bound_i(2)-bound_i(1))/dble(ni-1)
							maxvf = umin
							do i = 1, ni, 1
								in = bound_i(1) + dble(i-1)*gapi
								u = eq(s,e)*utility(cn/eq(s,e))
								an = xn - cn - fcost(in)
								fn = z + in
								call get_ev(s , e, y, o,  fn, an, 1, vnext, ev)
								guess = u + (1.0d0-mort(s,e))*beta*ev 
								if (guess .gt. maxvd(1)) then
									maxvd(1) = guess
									maxc(1) = cn
									maxi(1) = in
									gapi_max = gapi
								end if	
								if (guess .gt. maxvf) then
									maxvf = guess
								else if (i.gt.1) then
									exit
								else
									continue
								end if	
							end do
						end do						
		
					! attribute solution
					value(state) = maxvd(1)
					dvalue(state) = gridd(1)
					cvalue(state) = maxc(1)
					ivalue(state) = maxi(1)	

				! Both are possible	
				case (3)
					maxv = umin
														
					do n = 1, nd, 1	
						maxvd(n) = umin
						! start with coarse grid
						nc = int(dble(na))
						ni = int(dble(nf))

						if (n.ge.2) then
							xn = x - cost 
						else
							xn = x
						end if	

						! ******* need to iterate on grid ***********
						bound_c(1) = eqcmin
						bound_c(2) = xn
						
						bound_i(1) = 0.0d0
						bound_i(2) = fmax - z
							gapc = (bound_c(2) - bound_c(1))/dble(nc-1)
							!write(*,*) n, eqcmin, xn
							do c = 1, nc, 1
								cn = bound_c(1) + dble(c-1)*gapc
								if (bound_i(2).gt.finvcost(xn-cn)) then
									if (bound_i(2).gt.(fmax-z)) then
									bound_i(2) = fmax - z
									else 
										bound_i(2) = finvcost(xn-cn)
									end if
								end if	
								gapi = (bound_i(2)-bound_i(1))/dble(ni-1)
								maxvf = umin
								do i = 1, ni, 1
									in = bound_i(1) + dble(i-1)*gapi
									u = eq(s,e)*utility(cn/eq(s,e))
									an = xn - cn - fcost(in)
									fn = z + in
									call get_ev(s , e, y, o,  fn, an, n, vnext, ev)
									guess = u + (1.0d0-mort(s,e))*beta*ev 
									if (guess .gt. maxvd(n)) then
										maxvd(n) = guess
										maxc(n) = cn
										maxi(n) = in
										gapi_max = gapi
									end if	
									if (guess .gt. maxvf) then
										maxvf = guess
									else if (i.gt.1) then
										exit
									else
										continue
									end if	
								end do
							end do						
							
					end do
						
						
						

					! find maximum over risky asset share
					do n = 1, nd, 1
						if (maxvd(n).gt.maxv) then
							maxd = n
							maxv = maxvd(n)
						end if	
					end do
					
					value(state) = maxvd(maxd)
					dvalue(state) = gridd(maxd)
					cvalue(state) = maxc(maxd)
					ivalue(state) = maxi(maxd)
					
			
			end select												

					!!write(*,*) 'invt', ivalue(state), max
					!write(*,*) value(state), dvalue(state), cvalue(state), ivalue(state)
					if (ivalue(state).gt.0.0d0) then
						!write(*,*) 'positive investiment', ivalue(state) , x, inc, med
					end if

		end do ! end points had to do
		
	end subroutine get_opt

	subroutine get_ev(s , e, y, o, fn, an, n, vnext, ev)
		integer s, e, y, o, n, q
		double precision fn, an, ev, v(2,2)
		double precision pv, R, ar, au, fu
		double precision vnext(nq,ne,nf,na)
		integer env
		integer j,p,k, a0, a1, f0, f1
		
		if (s.ge.retage(e)) then
			if (n.eq.1) then
				env = 1
			else
				env = 2
			end if	
		else
			if (n.eq.1) then
				env = 3
			else
				env = 4
			end if
		end if
		
		if (ar.lt.amin) then
			ar = amin
		end if
		
		! find closest point to fn
		f0 = floor((fn - fmin)/gapf)+1
		if (f0.lt.1) then
			fn = fmin
			f0 = 1
			f1 = 2
		else if (f0.ge.nf) then
			f1 = nf
			f0 = nf - 1
		else 
			f1 = f0 + 1
		end if
		fu = (fn - gridf(f0))/(gridf(f1)-gridf(f0))
		ev = 0.0d0
		select case(env)
			! oop risk, no interest risk
			case (1)
				R = factor(fn, gridd(1), 0.0d0)
				ar = R*an
				a0 = floor((dsqrt(ar) - dsqrt(amin))/gapa)+1
				if (a0.lt.1) then
					ar = amin
					a0 = 1
					a1 = 2	
				else if (a0.ge.na) then
					ar = amax
					a1 = na
					a0 = na -1
				else	
					a1 = a0 + 1
				end if	
				au = (dsqrt(ar) - grida(a0))/(grida(a1)-grida(a0))
						
				do p = 1, no, 1
						call grid(y,p,q)
						v(1,1) = vnext(q,e,f0,a0)
						v(1,2) = vnext(q,e,f0,a1)
						v(2,1) = vnext(q,e,f1,a0)
						v(2,2) = vnext(q,e,f1,a1)	
						call blend_102(fu, au, v(1,1), v(1,2), v(2,1), v(2,2), pv)
						!write(*,*) x,R,fn,fu,an,ar,au,pv; !,v
						ev = ev + probo(e,o,p)*pv						
				end do			
				!write(*,*) 'with n = 1', an,R,ev

			! oop risk and interest risk
			case (2)			
				do k = 1, nr, 1
					R = factor(fn, gridd(n), pter(k))
					!write(*,*) 'with n = 2',an, R
					ar = R*an
					a0 = floor((dsqrt(ar) - dsqrt(amin))/gapa)+1
					if (a0.lt.1) then
						ar = amin
						a0 = 1
						a1 = 2	
					else if (a0.ge.na) then
						ar = amax
						a1 = na
						a0 = na -1
					else	
						a1 = a0 + 1
					end if	
					au = (dsqrt(ar) - grida(a0))/(grida(a1)-grida(a0))
					do p = 1, no, 1
							call grid(y,p,q)
							v(1,1) = vnext(q,e,f0,a0)
							v(1,2) = vnext(q,e,f0,a1)
							v(2,1) = vnext(q,e,f1,a0)
							v(2,2) = vnext(q,e,f1,a1)	
							call blend_102(fu, au, v(1,1), v(1,2), v(2,1), v(2,2), pv)
							!write(*,*) x,R,fn,fu,an,ar,au,pv; !,v
							ev = ev + probr(k)*probo(e,o,p)*pv						
					end do			
				end do
					!write(*,*) 'with n = 2',an, R, ev, fu, au
				
			! income risk, no rate risk
			case (3)
				R = factor(fn, gridd(n), 0.0d0)
				ar = R*an
				a0 = floor((dsqrt(ar) - dsqrt(amin))/gapa)+1
				if (a0.lt.1) then
					ar = amin
					a0 = 1
					a1 = 2	
				else if (a0.ge.na) then
					ar = amax
					a1 = na
					a0 = na -1
				else	
					a1 = a0 + 1
				end if	
				au = (dsqrt(ar) - grida(a0))/(grida(a1)-grida(a0))
						
				do j = 1, ny, 1
						call grid(j,o,q)
						v(1,1) = vnext(q,e,f0,a0)
						v(1,2) = vnext(q,e,f0,a1)
						v(2,1) = vnext(q,e,f1,a0)
						v(2,2) = vnext(q,e,f1,a1)	
						call blend_102(fu, au, v(1,1), v(1,2), v(2,1), v(2,2), pv)
						!write(*,*) x,R,fn,fu,an,ar,au,pv; !,v
						ev = ev + proby(e,y,j)*pv						
				end do						
			! income risk and rate risk
			case (4)
				do k = 1, nr, 1
					R = factor(fn, gridd(n), pter(k))
					ar = R*an
					a0 = floor((dsqrt(ar) - dsqrt(amin))/gapa)+1
					if (a0.lt.1) then
						ar = amin
						a0 = 1
						a1 = 2	
					else if (a0.ge.na) then
						ar = amax
						a1 = na
						a0 = na -1
					else	
						a1 = a0 + 1
					end if	
					au = (dsqrt(ar) - grida(a0))/(grida(a1)-grida(a0))
					do j = 1, ny, 1
							call grid(j,o,q)
							v(1,1) = vnext(q,e,f0,a0)
							v(1,2) = vnext(q,e,f0,a1)
							v(2,1) = vnext(q,e,f1,a0)
							v(2,2) = vnext(q,e,f1,a1)	
							call blend_102(fu, au, v(1,1), v(1,2), v(2,1), v(2,2), pv)
							!write(*,*) x,R,fn,fu,an,ar,au,pv; !,v
							ev = ev + probr(k)*proby(e,y,j)*pv						
					end do			
				end do
		end select				
	end subroutine get_ev

	subroutine simulate
		integer q, a0, a1, f0, f1, i, s, j, seed(1), k
		double precision eqcmin, au, fu, dtag(nf,na), ctag(nf,na), itag(nf,na), vtag(nf,na)
		character (len=80) :: header
		double precision earnsim, ds, cs, is, vs, inc, z, x, R, draw, vproby(ny), vprobo(no), age 	
		! allocate space for simulation arrays
		
		if (ismaster) then
			write(*,*) 'got to simulating'
			call flush()
			seed(1) = 12345
			k = 1
			call random_seed
			call random_seed(size=k)
			call random_seed(put=seed(1:k))
			
			allocate(esim(nsim,T))
			allocate(dsim(nsim,T))
			allocate(csim(nsim,T))
			allocate(isim(nsim,T))
			allocate(fsim(nsim,T))
			allocate(asim(nsim,T))
			allocate(ysim(nsim,T))
			allocate(osim(nsim,T))
			allocate(rsim(nsim,T))
			allocate(dead(nsim,T))
			allocate(incsim(nsim,T))
			allocate(oopsim(nsim,T))
			allocate(vsim(nsim,T))
			
	
			! simulate individuals
		
			write(*,*) '- will now simulate synthetic cohort ...'
						
			open(unit=3,file='/brinker-5/a/michaud/fin/data/initsample.csv') 
			read(3,*) header
			
			do i = 1, nsim, 1
				
				! take initial conditions from data
				! education level
				read(3,*) incsim(i,1),esim(i,1),asim(i,1)
				earnsim = earn(1, esim(i,1), 0.0d0)
				call point(dlog(incsim(i,1)/earnsim),ptey(esim(i,1),:), ny, ysim(i,1))
				if (asim(i,1).lt.amin) then
					asim(i,1) = amin
				end if	
				!write(*,*) log(incsim(i,1)/earnsim),ysim(i,1)
					
				! technology
				dsim(i,1) = gridd(1)
				
				! medical expenditures
				if (no.gt.1) then
					osim(i,1) = int(dble(no)/2.0d0)+1
				else
					osim(i,1) = 1
				end if	
				oopsim(i,1) = 0.0d0
				
				! real rate of return shock
				rsim(i,1) = 2
				
				! asset and financial knowledge start period
				call random_number(draw)
				if (esim(i,1).eq.1) then
					!fsim(i,1) = 0.0d0 + 10.0d0*quann(draw)
					fsim(i,1) = fmin					
					!fsim(i,1) = 25.0d0
				else if (esim(i,1).eq.2) then
					!fsim(i,1) = 25.0d0 + 10.0d0*quann(draw)
					fsim(i,1) = fmin
					!fsim(i,1) = 25.0d0
				else
					!fsim(i,1) = 50.0d0 + 10.0d0*quann(draw)
					fsim(i,1) = fmin
					!fsim(i,1) = 25.0d0

					!fsim(i,1) = 50.0d0
				end if
				if (fsim(i,1).gt.fmax) then
					fsim(i,1) = fmax
				end if
				if (fsim(i,1).lt.fmin) then
					fsim(i,1) = fmin
				end if

				dead(i,1) = 1	
				
				do s = 1, T-1, 1
					!write(*,*) i,s
					call flush()
					if (dead(i,s).eq.1) then
						oopsim(i,s) = oop(s, esim(i,s), pteo(esim(i,s),osim(i,s))) 
						!write(*,*) s, oopsim(i,s),osim(i,s)
						eqcmin = cmin*eq(s,esim(i,s))/((2.7d0)**0.7d0)
						! get state on grid for intrapolation
						call closest(dsqrt(asim(i,s)),dsqrt(amin),gapa,na,a0,a1)
						call closest(fsim(i,s),fmin,gapf,nf,f0,f1)
						!write(*,*) 'asset bounds',s,  asim(i,s-1),a0,a1
						!write(*,*) 'fin bounds', s, fsim(i,s-1),f0,f1
						au = (dsqrt(asim(i,s)) - grida(a0))/(grida(a1)-grida(a0))
						fu = (fsim(i,s) - gridf(f0))/(gridf(f1)-gridf(f0))
						
						! compute optimal technology
						call grid(ysim(i,s),osim(i,s),q)
						dtag =  dopt(s,q,esim(i,s),:,:)
						call blend_102(fu, au, dtag(f0,a0),dtag(f0,a1),dtag(f1,a0),dtag(f1,a1),ds)
					
						dsim(i,s+1) = ds
						
						!write(*,*) dsim(i,s+1)
						!write(*,*) 'choice of tech', s, ds, dsim(i,s)
						! intrapolate optimal consumption
						ctag =  copt(s,q,esim(i,s),:,:)
						call blend_102(fu, au, ctag(f0,a0),ctag(f0,a1),ctag(f1,a0),ctag(f1,a1),cs)
						csim(i,s) = cs	
						!write(*,*) 'choice of consumption', s, ctag(f0,a0),ctag(f0,a1),ctag(f1,a0),ctag(f1,a1), csim(i,s-1)
						
						! intrapolate optimal investment
						itag =  iopt(s,q,esim(i,s),:,:)
						call blend_102(fu, au, itag(f0,a0),itag(f0,a1),itag(f1,a0),itag(f1,a1),is)
						isim(i,s) = is
						if (is.gt.0.0d0 ) then
							!write(*,*) 'choice of investment', i, s, isim(i,s),fsim(i,s),asim(i,s),esim(i,s),dsim(i,s)
						end if
						
					   ! intrapolate value function (to get utility)
						vtag =  vopt(s,q,esim(i,s),:,:)
						call blend_102(fu, au, vtag(f0,a0),vtag(f0,a1),vtag(f1,a0),vtag(f1,a1),vs)
						vsim(i,s) = vs
						
						! first transition to 2
						!write(*,*) ' coeff are ', s,bw(:,esim(i,s-1))
						if (s.ge.retage(esim(i,s))) then
							inc = retinc(s, esim(i,s),ptey(esim(i,s),ysim(i,s)))						
						else
							inc = earn(s, esim(i,s),ptey(esim(i,s),ysim(i,s)))
						end if
						incsim(i,s) = inc
						!write(*,*) 'income is ',s,incsim(i,s), ysim(i,s), esim(i,s)
						!write(*,*) 'factor is ',s,R
						! net financial knowledge
						z = fdepreciate(s)*fsim(i,s)	
					
						
						! cash-on-hand
						x = inc + asim(i,s) - oopsim(i,s)
						! transfers
						if (x.lt.eqcmin) then
							x = eqcmin
						end if
						!write(*,*) 'x is ',s,x
						
						
						! end of period financial lit
						fsim(i,s+1) = z + isim(i,s)
						if (fsim(i,s+1).gt.fmax) then
							fsim(i,s+1) = fmax
						else if (fsim(i,s+1).lt.fmin) then
							fsim(i,s+1) = fmin
						end if
						!write(*,*) 'f end of period is ',s,fsim(i,s)
			
						! draw shock to interest rate
						
						call random_number(draw)
						do j = 1, nr, 1
							!write(*,*) 'shock prob ', s, j, draw, vprob(j)
							if (draw.lt.cumprobr(j)) then
								rsim(i,s+1) = j
								exit
							end if
						end do	
						
						! end of period assets
						R = factor(fsim(i,s+1), dsim(i,s+1), pter(rsim(i,s+1)))
						
						asim(i,s+1) = x - csim(i,s) - fcost(isim(i,s)) 
						if (dsim(i,s+1).gt.dmin ) then
							asim(i,s+1) = asim(i,s+1) - k0*dexp(-k1*z)
						end if 
						asim(i,s+1) = R*asim(i,s+1)
						!write(*,*) fsim(i,s+1),R
						if (asim(i,s+1).gt.amax) then
							asim(i,s+1) = amax
						else if (asim(i,s+1).lt.amin) then
							asim(i,s+1) = amin
						end if	
						
						!write(*,*) 'a end of period is ',s,asim(i,s)
						esim(i,s+1) = esim(i,s)
						
						! draw shock to income
						
						if (s.lt.retage(esim(i,s))) then
							call random_number(draw)
							vproby = cumproby(esim(i,s),ysim(i,s),:)
							do j = 1, ny, 1
								!write(*,*) 'shock prob ', s, j, draw, vprob(j)
								if (draw.lt.vproby(j)) then
									ysim(i,s+1) = j
									exit
								end if
							end do	
						else
							ysim(i,s+1) = ysim(i,s)
						end if
						
						
						
						! draw shock to out-of-pocket
						if (s.ge.retage(esim(i,s))) then
							call random_number(draw)
							vprobo = cumprobo(esim(i,s),osim(i,s),:)
							do j = 1, no, 1
								if (draw.lt.vprobo(j)) then
									osim(i,s+1) = j
									exit
								end if
							end do	
						else
							osim(i,s+1) = osim(i,s)
						end if
						
						! decide whether survive
						call random_number(draw)
						if (draw.lt.mort(s,esim(i,s))) then
							!write(*,*) 'died at ', s
							dead(i,s+1) = 2
							exit
						else 
							dead(i,s+1) = 1
						end if
						if (s.eq.T-1) then
							dead(i,s+1) = 2
							exit
						end if	
					end if			
					
				end do
				
			end do
			close(3)
			
		
			write(*,*) '- cohort simulated, saving dataset ...'
							
			open (8,file='/brinker-5/a/michaud/fin/data/simknow.dat',status='old')
			do i=1,nsim,1
				do s = 1, T-1, 1
					age = real(24+s)
					if (dead(i,s).eq.1) then
						write(8,*) i,age,vsim(i,s),csim(i,s),asim(i,s),incsim(i,s),oopsim(i,s),rsim(i,s),isim(i,s),fsim(i,s),esim(i,s),dsim(i,s)
					end if
				end do
			end do	
			close(8)
		end if
		call mpi_barrier(MPI_COMM_WORLD, ier)
	end subroutine simulate
	

	double precision function probn(value)
		double precision value,  q, bound
		integer ifail, status
		!double precision g01eaf
      	!external g01eaf
		!ifail = 1
		call cdfnor(1,probn,q, value, 0.0d0, 1.0d0, status, bound)
		! function that gives the cumulative probability from normal
		!probn = g01eaf('L',value,ifail)
		!write(*,*) prob
	end function

	double precision function quann(prob)
		double precision prob, bound
		integer ifail, status
		!double precision g01faf
      	!external g01faf
		ifail = 1
		call cdfnor(2,prob,1.0d0-prob, quann, 0.0d0, 1.0d0, status, bound)
		! function that gives the cumulative probability from normal
		!quann = g01faf('L',prob,ifail)
		!write(*,*) prob
	end function

	!* state of shock
	subroutine grid(y, o, q)
		integer q, y, o
		q = (y-1)*no + o
	end subroutine
		
	!* utility function
	double precision function utility(x)
		double precision x
		if (x.gt. 0.0d0) then
				utility = (x**(1.0d0-gamma))/(1.0d0-gamma) 
			else
				utility = umin
		end if
	end function
	
	!* bequest function
	double precision function bequest(x)
		double precision x
		if (x.ge. amin) then
				bequest = phi*((x+50000.0d0)**(1.0d0-gamma))/(1.0d0-gamma) 
			else
				bequest = umin
		end if
	end function
	
	double precision function fcost(i)
		double precision i
		if (i.le.0.0d0) then
			fcost = 0.0d0
		else		
			fcost = pi0*(i**pi1)
		end if	
	end function
	double precision function finvcost(c)
		double precision c
		if (c.le.0.0d0) then
			finvcost = 0.0d0
		else
			finvcost = (c/pi0)**(1.0d0/pi1)
		end if	
	end function
	
	double precision function fdepreciate(s)
		integer s, s1
		s1 = s
		if (s1.gt.22) then
			s1 = s1-22
		else
			s1 = 0
		end if	
		fdepreciate = dexp(delta0 - delta1*dble(s1))
	end function
	
	! compute interest rate
	double precision function factor(fpt, tech, shock)
		double precision fpt, rf, shock, tech
		rf = alpha0*(fpt**alpha1)
		rf = rf  + sigr*shock + rbar
		factor = 1.0d0 +tech*rf + (1.0d0-tech)*rbar - inflation
	end function
	
	! compute earnings
	double precision function earn(s, e, py)
		integer s, e
		double precision py, age, agesq
			age = dble(25+s)
			agesq = 0.01d0*(age**2)
			earn = dexp(bw(3,e) + bw(1,e)*age + bw(2,e)*agesq -0.5d0*incsig(e) +  py)
	end function
	! compute retirement income
	double precision function retinc(s, e, py)
		integer s, e, age
		double precision work, rep, py
			age = 25+s
			work = earn(retage(e)-1,e,0.0d0)
			rep = br(age-64,e)
			retinc = work*rep
			
			if (age<=70) then 
				!write(*,*) age, work, rep, retinc
				end if
	end function

	! compute out-of-pocket expenditures
	double precision function oop(s, e, po)
		integer s, e
		double precision po, age, agesq
		if (s.ge.retage(e)) then
			age = dble(25+s)
			agesq = 0.01d0*(age**2)
			oop = dexp(bo(1,e)*age + bo(2,e)*agesq  + bo(3,e) + po)
		else 
			oop = 0.0d0
		end if	
		!write(*,*) oop, po, age , agesq, bo(1:3,e)
	end function
	
	! routine to find the closest point index on a grid
	subroutine closest(val, minval, step, n, low, up)
		double precision val, step,minval
		integer n, low, up		
		low = int(floor((val - minval)/step))+1
		if (low.lt.1) then
			low = 1
			up = 2
		else if (low.eq.n) then
			up = low
			low = low - 1
		else
			up = low + 1
		end if		
	end subroutine
	
	! routine to find the closest point on a grid
	subroutine point(val, grid, n, p)
		integer n,i,imin,p
		double precision val, grid(n),diff,dmin
		dmin = 1.0d20; imin = 1
		do i = 1,n,1
			diff = dabs(val - grid(i))
			if (diff.lt.dmin) then
				dmin = diff
				imin = i
			end if	
		end do
		p = imin
	end	subroutine

	! routine to linearly intrapolate in two dimensions
	subroutine blend_102 ( r, s, x00, x01, x10, x11, x )
	  double precision r, s, x, x00,x01,x10,x11
	  x = x00 + r*(-x00+x10) + s*(-x00+x01) + r*s*(x00 - x10 - x01 + x11 )	
	end subroutine
	
	subroutine get_modulename
		if (ismaster) then
			write(*,*) '* optimal knowledge model (Lusardi, Michaud and Mitchell) *'
		end if
	end subroutine get_modulename
end module know


!* Distribution functions for shocks --------------------------------




program main
use know
	call initmpi
	call get_modulename
	call initpar
	call statespace
	call solve
	call simulate
	call stopmpi
end program main